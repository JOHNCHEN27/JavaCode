package com.lncanswer.colletionAdvanced.collection.list;

/**
 * @author LNC
 * @version 1.0
 * @description
 * @date 2023/9/8 15:24
 */
public class LinkedListBase {
    /**
     * LinkedList底层是双链表 查询慢，增删改快，查询首位元素极快
     * 比普通list多了一些API
     * public void addFirst(E e) 在该列表开头插入指定元素
     * public void addLast(E e)  在该列表结尾添加元素
     * public E getFirst()
     * public E getLast()
     * public E removeFirst() 删除列表中第一个元素并将其返回
     * public E removeLast() 删除列表中最后一个元素并返回
     */
    public static void main(String [] args){

    }

    /**
     * 普通二叉树： 没有顺序  树的遍历方式氛围前序（根、左、右）、中序、后续
     * 二叉排序树（二叉查找树、二叉搜素树）：每个结点的左子树比自身小 每个结点的右子树比自身大
     * 缺陷：存在长度不一情况，出现这种情况时，几乎和链表差不多 失去了树的功能
     * 为了改进这种情况 出现了平衡二叉树
     *
     * 平衡二叉树：继承了二叉查找树所有特性
     * 在二叉排序树的基础上需要保证树中的每个结点的左右子树高度差不能超过 1 才是平衡二叉树
     * 当加入或删除结点时，破坏了平衡二叉树的性质，此时需要进行旋转来恢复
     * 旋转分为：左旋、右旋
     * 左旋：找到破坏平衡的结点，将此结点往左边上面旋转，上面的结点降级为此结点的左结点
     * 如果此结点还带有左子树 把这个左子树作为降级结点的右子树
     * 右旋：找到破坏平衡的结点，将此结点往右边上面选择，上面的结点降级为此结点的右子树
     * 如果此结点带有右子树，把这个右子树作为降级结点的左子树
     *
     * 旋转有四种情况：左左、左右、右右、右左
     * 左左：当根结点的左子树插入一个左子树时，此时只需要一次右旋就能回复平衡
     * 左右：当根结点的左子树插入一个右子树时，此时要先将左子树局部左旋，回复局部平衡，
     * 再将整体右旋即可恢复平衡
     * 右右：当根结点的右子树插入一个右子树时，此时只需要一次左旋就能恢复平衡
     * 右左：当根结点的右子树插入一个左子树时，此时需要将局部先右旋恢复平衡，
     * 再将整体左旋即可恢复平衡
     *
     *
     * 红黑树： 为了改进平衡二叉树的严厉规则的平衡二叉树
     * 特点：不依据高度判断是否平衡，拥有二叉排序树的特点，拥有自己判断平衡的红黑规则
     * 如何判断红黑树：
     * 1、每一个结点是红色或者是黑色的
     * 2、根节点和叶结点必须是黑色的
     * 3、两个红色的结点不能直接相连
     * 4、任意结点到所有后代叶节点的简单路径上，黑色结点的数量相同
     * 需要注意点是：每一个结点没有左右子树时会添加两个作为左右子树的nil（空结点） 它是黑色的
     * 关于添加规则如何保证平衡需要再去看资料、视频细化
     */
}
